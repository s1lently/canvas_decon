你搜集一下 为什么无论ubuntu自带的截图工具 还是用chrome里的copy image 将图片复制到copyboard 都没有办法在claude code cli里 还是gemini cli里粘贴 而windows和linux就可以 你查查

报告:
# Why Linux clipboard images won't paste into CLI tools

The root cause is architectural: **Linux terminals only request text data from the clipboard**, while the clipboard itself uses a deferred rendering model where source applications must remain running to provide data. Unlike Windows/macOS which store clipboard data centrally, Linux's X11/Wayland systems use peer-to-peer transfers that terminals simply don't participate in for binary content. CLI tools that work around this on other platforms do so by accessing system clipboard APIs directly—a capability that Linux's display-server-dependent architecture makes significantly more complex.

## X11 and Wayland clipboard architecture creates fundamental barriers

Linux clipboard systems use a **selection model** with three separate mechanisms: PRIMARY (mouse selection, middle-click paste), SECONDARY (rarely used), and CLIPBOARD (explicit Ctrl+C/V operations). The critical architectural difference from Windows/macOS is that **no central clipboard storage exists**. When you copy an image, the source application merely claims ownership of the selection—the image data stays in that application's memory until another program requests it.

This "deferred rendering" or "lazy evaluation" model has significant implications. The X server acts only as a broker: when you paste, the target application sends an `XConvertSelection()` request, and the source application must convert and transfer the data on demand. **If the source application closes, the clipboard content vanishes**—unless a clipboard manager intercepts and caches it.

Image data in X11 uses MIME-type targets like `image/png`, `image/jpeg`, and `image/bmp`. Applications advertise available formats through the TARGETS mechanism, and requesters negotiate their preferred format. For large images exceeding the ~256KB window property limit, the **INCR (incremental) protocol** chunks data into 256KB-1MB segments. Wayland simplifies some of this by using file descriptors instead of window properties, but adds a security constraint: **only the focused application can read clipboard data**, preventing background processes from clipboard access entirely.

## Terminals request only text because the PTY architecture predates images

When you press Ctrl+V in any terminal emulator—GNOME Terminal, Konsole, Alacritty, kitty, or xterm—the terminal requests specific clipboard targets: `UTF8_STRING`, `STRING`, `TEXT`, or `text/plain`. **Terminals never request image MIME types** like `image/png`. This isn't an oversight; it reflects the fundamental nature of how terminals work.

The terminal architecture traces back to **teletypewriters (TTYs)**—electromechanical devices that sent keystrokes over serial lines and printed characters on paper. Modern pseudoterminals (PTYs) preserve this text-centric design. When you paste:

1. The terminal emulator receives text from the clipboard
2. Text bytes are written to the PTY master (`/dev/ptmx`)  
3. The TTY driver/line discipline processes the byte stream
4. Data arrives at the PTY slave (`/dev/pts/N`) connected to your shell's stdin

The line discipline layer is designed for character processing—it handles control characters like `^C` and `^Z`, provides line editing, and manages buffering. **Binary image data would be corrupted** by this processing in normal "cooked" mode, and even raw mode doesn't help because the terminal simply never requests images from the clipboard in the first place.

Some terminals support image *display* through proprietary escape sequence protocols—kitty's graphics protocol, iTerm2's inline images, and the legacy Sixel format. These allow CLI applications to *output* images that terminals render. But crucially, **these protocols don't enable clipboard paste of images**. They're a separate rendering pathway where applications explicitly transmit base64-encoded image data through escape sequences; the paste mechanism remains text-only.

## Windows and macOS solve this with centralized clipboard services

The contrast with Windows and macOS explains why image pasting "just works" on those platforms. Both operating systems provide **centralized, always-available clipboard services** that store data in system buffers rather than requiring the source application to remain running.

Windows uses the Win32 Clipboard API with formats like `CF_DIB` (device-independent bitmap) and `CF_BITMAP`. The system provides automatic format synthesis—if you copy in one bitmap format, Windows synthesizes others on request. macOS uses `NSPasteboard` with a Uniform Type Identifier (UTI) system (`public.png`, `public.tiff`) that provides similar automatic format negotiation. Neither requires a display server; clipboard is a system service accessible from any process.

However, here's a critical insight: **even on Windows and macOS, terminals don't actually paste images**. Command Prompt, PowerShell, and Terminal.app are still text-only interfaces. The difference is that CLI applications on these platforms can **access the clipboard API directly** through straightforward system calls. A Node.js application on Windows can use PowerShell's `Get-Clipboard -Format Image`, and on macOS tools like `pngpaste` access `NSPasteboard` natively. The terminal acts as a text rendering surface while the CLI application makes its own clipboard calls in the background.

Linux's architecture makes this direct access more complex. CLI tools require a running X11 or Wayland session with valid `$DISPLAY` or `$WAYLAND_DISPLAY` environment variables. They must link against X11/Wayland client libraries. SSH sessions without X forwarding cannot access the clipboard at all. The fragmentation between X11 (xclip, xsel) and Wayland (wl-copy, wl-paste) tools adds another layer of complexity for cross-platform applications.

## Claude Code CLI and Gemini CLI have documented Linux image paste failures

Both major AI CLI tools exhibit this exact problem. **Claude Code CLI** has multiple open GitHub issues (#834, #1361, #6076) documenting the inability to paste images on Linux via Ctrl+V, with combined reactions of 60+ users affected. On macOS, `Ctrl+V` (not `Cmd+V`) successfully pastes clipboard images; the tool accesses the system pasteboard directly. On Linux, this pathway fails because the underlying clipboard access mechanisms aren't implemented with the same robustness.

**Gemini CLI** faces identical challenges, with GitHub issues #5316, #2279, and #3955 tracking image support requests. An active pull request (#13645 from November 2025) is implementing cross-platform clipboard image pasting using the `@crosscopy/clipboard` Node.js package. The proposed solution saves clipboard images to a `.gemini-clipboard/` directory and substitutes file path references when users press Ctrl+V—essentially automating the manual workaround Linux users currently employ.

The core pattern these tools follow (or attempt to follow) is:

| Platform | Image paste mechanism |
|----------|----------------------|
| macOS | Direct NSPasteboard access via native bindings |
| Windows | PowerShell `Get-Clipboard` or .NET `System.Windows.Forms.Clipboard` |
| Linux | Subprocess calls to xclip/wl-paste (often incomplete) |

Cross-platform Node.js libraries like `clipboardy` support text across all platforms but typically require additional packages like `@crosscopy/clipboard` or `img-clipboard` for image support—and these depend on xclip or wl-clipboard being installed on Linux.

## Practical workarounds exist but require manual intervention

Until CLI tools implement proper Linux clipboard integration, several workarounds provide image input capability:

**Save clipboard to file, then reference the path:**
```bash
# X11
xclip -selection clipboard -t image/png -o > screenshot.png
claude "Analyze this image" screenshot.png

# Wayland  
wl-paste -t image/png > screenshot.png
gemini "What's in this image?" screenshot.png
```

**Kitty terminal with custom paste script** offers the most seamless experience. A shell script can detect image content in the clipboard, save it to `/tmp`, and inject the file path into the terminal:

```bash
#!/bin/bash
# Detect clipboard content type and handle appropriately
if xclip -selection clipboard -t TARGETS -o | grep -q '^image/'; then
    file="/tmp/clip_$(date +%s).png"
    xclip -selection clipboard -t image/png -o > "$file"
    printf '%q' "$file"  # Output path for CLI tool
else
    xclip -selection clipboard -o  # Normal text paste
fi
```

**Kitty's clipboard kitten** provides built-in image handling:
```bash
kitten clipboard -g image.png  # Save clipboard image to file
kitten clipboard image.png     # Copy image to clipboard
```

**Shell aliases** can streamline the workflow:
```bash
alias clip2img='xclip -selection clipboard -t image/png -o > "$(date +%Y%m%d_%H%M%S).png" && echo "Saved to $(date +%Y%m%d_%H%M%S).png"'
```

## Conclusion

The inability to paste clipboard images into Linux CLI tools stems from multiple architectural layers: the X11/Wayland selection model that uses deferred rendering rather than central storage; terminal emulators that request only text MIME types due to the TTY heritage; and the additional complexity of accessing Linux clipboard APIs compared to Windows/macOS system calls. CLI tools like Claude Code and Gemini CLI work around this on other platforms by accessing clipboard APIs directly, but Linux implementations lag behind. Until tools like Gemini CLI's pending cross-platform clipboard PR become standard, Linux users must manually save clipboard images to files and reference paths—a workflow that xclip, wl-paste, and kitty's clipboard kitten can streamline but not eliminate.



